1. 객체 지향의 특징 4가지에 대해 정리하기

- Object(객체) ? 세상에 존재하는 모든 것 -> 주변에 잇는 사물, 생명체 같은 모든 것
- 프로그래밍에서의 객체 ? 데이터의 분산을 막기 위해 데이터와 기능을 하나로 묶은 그룹
- 객체지향언어(Object-oriented Language)? 
: 컴퓨터 프로그래밍의 한 기법
: 객체를 만들고 객체를 사용하는 프로그래밍 방법
: 프로그램을 다수의 객체를 만들고, 이들이 서로 상호작용을 통해 만들어지는 방식
(예) 컴퓨터(PC)
컴퓨터 한대를 완성하려면 =>  CPU, RAM, BOARD, SSD, HDD, VGA, POWER, CASE 등 여러가지 부품 필요
부품 하나하나가 연결되고 조립이 되어야 컴퓨터의 기능이 제대로 작동되고 사용 할 수 있음.
* 여기서 컴퓨터 부품(주변기기)들을 객체라고 생각하시면 됩니다.
각 부품들의 역할이 나뉘어져 있고 사용하고자 하는 부분에 대해서 각 부품들이 작동을 하게 됩니다.
고장이 나더라도 해당 부품만 수리 및 교체를 하면 간단하게 해결 가능 -> 유지보수도 쉽고 편함
=> 명령어들로 이루어진 목록이 아닌 하나하나의 독립된 객체들의 그룹
=> 객체간의 메시지를 주고 받음으로서 쉽게 연결 가능.

> Encapsulation(캡슐화)
: 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈/클래스 내부로 감추는 것
: 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것
: 데이터와 코드의 형태를 외부로부터 알 수 없도록 하고 데이터 구조+역할+기능을 하나의 캡슐 형태로 만드는 방법
=> 데이터와 알고리즘을 하나로 묶는 것
: 정보 은닉을 이용해 높은 응집도 + 낮은 결합도를 갖도록 함
- 캡슐화된 객체의 세부 내용이 외부에 은폐(정보 은닉)되어, 변경이 발생할 때 오류의 파급효과가 적음. 
- 캡슐화된 객체들은 재사용이 용이
- 높은 응집도 + 낮은 결합도 유지하도록 설계해야 요구사항을 변경할 시 유연하게 대처 가능
? 응집도(Cohesion) ? 클래스나 모듈 안의 요소들이 얼마나 밀접하게 관련되어 있는가
? 결합도(Coupling) ? 어떤 기능을 실행하는 데 다른 클래스/모듈들에 얼마나 의존적인가 
- Information Hiding(정보은닉)
: 캡슐화에서 가장 중요한 개념
: 필요 없는 정보는 외부에서 접근하지 못하도록 제한하는 것, private 키워드
: 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것.
Q. 정보 은닉이 왜 필요한가 ?
A. 
1) 소프트웨어는 결합이 많을 수록 문제가 많이 발생함
2) 한 클래스가 변경이 발생하면 변경된 클래스의 비밀에 의존하는 다른 클래스들도 
변경해야할 가능성이 커진다는 의미

* 접근제어자 : public > protected > default > private
Q.  접근제어자를 사용하는 이유 ?
A .
1) 외부로부터 데이터를 보호하기 위해
2) 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해


> Abstarction(추상화)
: 객체에서 공통된 속성+행위를 추출하는 것
: 불필요한 부분을 생략하고 객체의 속성 중 가장 중요한 것에만 중점을 두어 개략화하는 것( == 모델화 하는 것)
: 객체의 공통적인 속성 + 기능을 추출해 정의하는 것
=> 실제로 존재하는 객체들을 프로그램으로 만들기 위해 공통적인 특성을 파악해서 
필요없는 특성을 제거하는 과정 
: 어떤 영역에서 필요로 하는 속성/행동을 추출하는 작업
: 사물들의 공통 특징(-> 추상적인 특징)을 파악해 인식의 대상으로 삼는 행위
: 구체적인 사물들의 공통적인 특징을 파악해 하나의 개념/집합으로 다루는 수단 
- 추상클래스 ? = 미완성 설계도 
: 상속을 통해 하위 클래스에 의해서만 완성 가능
: 새로운 클래스를 작성할 때 아무것도 없는 상태에서 시작하는 것보단느 완전하진 못해도 어느정도 틀을 갖춘 상태에서 
시작하는 것이 나을 것 !

* 인터페이스
: 일종의 추상클래스
추상클래스 = 미완성 설계도 (부분적으로만 완성)
인터페이스 = 기본 설계도 ( 구현된 건 아무것도 없고 밑그림만 그려져 있음)
: 모든 멤버변수 => public static final 이어야 함 : 생략 가능
: 모든 메소드 => public abstract 이어야 함 : 생략 가능 
(장점) 
1. 개발시간 단축
-> 메소드 호출하는 쪽에서 메소드 내용에 관계없이 선언부만 알면 되기 때문
-> 동시에 다른 한 쪽에선 인터페이스를 구현하는 클래스를 작성하도록 하여, 
인터페이스를 구현하는 클래스가 작성될 때 까지 기다리지 않고도 동시에 개발 진행 가능
2. 표준화 가능
-> 프로젝트에 사용되는 기본틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 
프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램의 개발 가능
3. 서로 관계 없는 클래스들에게 관계 맺음 가능
4. 독립적인 프로그래밍 가능 (특정 프로그램에 종속적이지 않음)
-> 클래스와 클래스 간의 직접적인 관계를 인터페이스를 이용해 간접적인 관계로 변경하면, 
한 클래스의 변경이 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍 가능

> Inheritance(상속성)
: 상위 클래스의 모든 것을 하위 클래스가 전부 이어 받는 것.
: 기존 클래스를 재사용해 새로운 클래스를 작성하는 것
- 보다 적은 코드로 새로운 클래스를 작성할 수 있음.
- 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가/변경에 매우 용이 
=> 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성+유지보수에 큰 기여.
=> 부모가 자식에게 유전자 물려주는 것과 같이 부모의 특징을 자식에게 모두 물려줌
: 이미 정의된 상위 클래스(부모 클래스)의 모든 속성솨 연산을 하위 클래스가 물려받는 것.
- 상속성을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 
자신의 클래스 내에서 다시 정의하지 않고서도 즉시 자신의 속성으로 사용 가능.
ex) extends



> Polymorphism(다형성)
= 다양한 형태로 나타날 수 있는 능력
: 상위클래스 타입의 참조변수로 하위클래스의 인스턴스를 참조 가능
: 메시지에 의해 개체(클래스)가 연산을 수행하게 될 때 
하나의 메시지에 대해 각 객체(클래스)가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 것(능력).
: 상속과 연관된 개념 => 한 객체가 다른 여러 형태의 개게로 재구성 되는 것
: 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 ㅣ방식으로 동작하는 능력
 : = 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답을 함.
ex1) 오버로딩(overloading)
: 같은 이름의 메소드를 여러개 정의
- 하나의 이름으로 정의함으로써 하나의 이름만 기억하면 되니까 기억하기도 쉽고 같은 기능을 하는 것을 쉽게 예측 가능
- 메소드 이름 절약 가능
ex2) 오버라이딩(overriding)


> 객체지향언어의 장단점
// 객체지향언어의 장점
1. 재사용성 : 상속을 통해 프로그래밍 시 코드의 재사용을 높일 수 있음.
2. 생산성 향상 : 잘 설계된 클래스를 만들어서 독립적인 객체를 사용함으로써 개발의 생산성 향상
3. 자연적인 모델링 : 일상생활 모습의 구조가 객체에 자연스럽게 녹아들어져 있기에 생각하고 있는 것을 그대로 자연스럽게 구현 가능
4. 유지보수의 우수성 : 프로그램을 수정하면서 추가/수정을 하더라도 캡슐화를 통해 
주변 영향이 적기 때문에 유지보수 쉬움. => 매우 경제적

//객체지향언어의 단점
1. 개발 속도 느림 : 객체가 처리하려는 것에 대한 정확한 이해가 필요하기에 설계단계부터 많은 시간 소모
2. 실행속도가 느림 : 객체지향언어는 대체적으로 실행속도 느림
3. 코딩 난이도 상승 : 다중 상속이 지원되는 경우(C++) 너무 복잡해져서 난이도 상승 가능
 